/*Скахин А.Н.http://skahin.blogspot.com*/function Canvas() {  this.width;  this.height;  this.canvas;  this.elements;  this.version = "Canvas Photo Editor (With Lib Raphael)";  this.ImgHoverStroke = {"stroke": "blue", "stroke-width": 2};  this.ImgSelectStroke = {"stroke": "green", "stroke-width": 2};  this.DefaultStroke = {"stroke-width": 1, "stroke": "#000"};  this.position;  this.ImageStroke;  this.SelectedObjectId;  this.browser = jQuery.browser;  this.allowAttrs = new Array("cx","cy","fill","fill-opacity","height","path","r",                              "rx","ry","src","stroke","stroke-width","x","y",                              "clip-rect", "font", "font-family", "font-size", "font-weight",                              "gradient", "rotation", "scale", "stroke-dasharray",                              "stroke-linecap", "stroke-linejoin", "stroke-miterlimit",                              "stroke-opacity"/*, "translation"*/, "text");   this.viewMinus = 0;  //конструктор  this.createCanvas = function(id, w, h) {    this.position = id;    $(id).html('');    this.width = w;    this.height = h;    this.canvas =  Raphael(id, w, h);    if(this.browser.msie == false) {      $(this.canvas.desc).text(this.version);    } else {      //$(this.position).children("DIV:first-child").children(".rvml").prepend("<!--" + this.version + "-->");    }    this.elements = new Array();    this.ImageStroke = new Array();    this.SelectedObjectId = undefined;    document.obj.select.options.length = 0;    $("#attr").val('');        //стили канвы    //this.elements[0] = this.canvas.canvas;    //this.registrMouseUpEvent(0);  }    this.createCanvasByDiv = function(id) {    //this.createCanvas(id, $(id).width(), $(id).height());    this.createCanvas(id, 800, 600);  }    this.mouseCoords = function(ev, obj, deltaX, deltaY){    ev = ev || window.event;    var x, y;    if(ev.pageX || ev.pageY){        x = ev.pageX;        y = ev.pageY;    } else {        x = ev.clientX + document.body.scrollLeft - document.body.clientLeft;        y = ev.clientY + document.body.scrollTop  - document.body.clientTop;    }    x = x - $(this.position).position().left;    y = y - $(this.position).position().top;        if(obj != undefined) {      if(obj.attr("width") != undefined) {        x = x - obj.attr("width")/2;        y = y - obj.attr("height")/2;      }    }    if(deltaX != undefined) {      x += deltaX;    }    if(deltaY != undefined) {      y += deltaY;    }    return {"x": x ,"y": y};  }    this.getPathCoords = function(path) {    var s = new String(path).replace("M","").replace("L","").split(" ");    var s1 = s[0].split(",");    var s2 = s[1].split(",");    return {"s":s1, "f":s2};  }    //события  this.registrDragEvents = function(element) {    var tmp = this;    var obj = this.getObjById(element);    var onDrag = false;    var lineCords;    var type = this.getObjType(obj);    var deltaX = 0, deltaY = 0;    obj.node.onmousedown = function(ev) {      if(tmp.browser.msie == false && tmp.browser.opera == false) {        ev.preventDefault(); //ff bug      }      onDrag = true;      var cord = tmp.mouseCoords(ev, obj);      if(type == "Circle"||type == "Ellipse") {        deltaX = obj.attr("cx") - cord.x;        deltaY = obj.attr("cy") - cord.y;      } else if(type == "Image"||type == "Rect"||type == "Text") {        deltaX = obj.attr("x") - cord.x;        deltaY = obj.attr("y") - cord.y;      } else if(type == "Line") {        lineCords = tmp.getPathCoords(obj.attr("path"));        deltaX = lineCords.f[0] - (lineCords.f[0] - lineCords.s[0])/2 - cord.x;        deltaY = lineCords.f[1] - (lineCords.f[1] - lineCords.s[1])/2 - cord.y;      } else {        deltaX = deltaY = 0;      }      $("#attr").val(tmp.getObjAttrString(obj));    }    obj.node.onmouseup = function(ev) {      if(tmp.browser.msie == false && tmp.browser.opera == false) {        ev.preventDefault(); //ff bug      }      onDrag = false;    }    obj.node.onmousemove = function(ev) {      if(onDrag) {        if(tmp.browser.msie == false && tmp.browser.opera == false) {          ev.preventDefault(); //ff bug        }        var cords = tmp.mouseCoords(ev, obj, deltaX, deltaY);        if(type == "Image"||type == "Rect"||type == "Text") {//image, rect, text          obj.attr("x", cords.x);          obj.attr("y", cords.y);          if(type == "Image") { //перемещаем выделение            tmp.ImageStroke[element].attr("x", cords.x);            tmp.ImageStroke[element].attr("y", cords.y);          }        } else if(type == "Circle"||type == "Ellipse") {//circle, ellipse          obj.attr("cx", cords.x);          obj.attr("cy", cords.y);        } else if(type == "Line") { //line          obj.attr("path", "M"+(cords.x-((lineCords.f[0]-lineCords.s[0])/2))+"," +                            (cords.y-(lineCords.f[1]-lineCords.s[1])/2)+                            " L"+(cords.x+(lineCords.f[0]-lineCords.s[0])/2)+","+                            (cords.y+(lineCords.f[1]-lineCords.s[1])/2));        }      }    }  }    this.registrHoverEvent = function(element) {    var tmp = this;    var obj = this.getObjById(element);    obj.node.onmouseover = function () { //не срабатывает в ie для текста      if(element != undefined && tmp.SelectedObjectId != element) {        if(tmp.isImage(obj)) {          tmp.ImageStroke[element].attr(tmp.ImgHoverStroke);          tmp.ImageStroke[element].show();        }        else {          obj.attr(tmp.ImgHoverStroke);        }      }    }    obj.node.onmouseout = function () {      if(element != undefined && tmp.SelectedObjectId != element) {        if(tmp.isImage(obj)) {          tmp.ImageStroke[element].hide();        } else {          obj.attr(tmp.DefaultStroke);        }      }    }    obj.node.onclick = function() {      tmp.selectObject(element);    }  }    this.deselectObject = function(element) {    var obj = this.getObjById(element);    if(obj == undefined) return;    if(this.isImage(obj)) {      this.ImageStroke[element].hide();    } else {      obj.attr(this.DefaultStroke);    }    this.SelectedObjectId = undefined;    this.setObjOnList(this.SelectedObjectId);    $("#attr").val('');  }    this.selectObject = function(element) {    var obj = this.getObjById(element);    if(obj == undefined) return;    if(this.SelectedObjectId == element) {      this.deselectObject(this.SelectedObjectId);      return;    }    this.deselectObject(this.SelectedObjectId);    this.SelectedObjectId = element;    //deselect prev obj    if(this.isImage(obj)) {      this.ImageStroke[element].attr(this.ImgSelectStroke);      this.ImageStroke[element].show();    } else {      obj.attr(this.ImgSelectStroke);    }    this.setObjOnList(this.SelectedObjectId);    $("#attr").val(this.getObjAttrString(obj));  }    this.setObjOnList = function(pos) {    for(var i = 0; i < document.obj.select.options.length; i++) {      if(document.obj.select.options[i].value == pos) {        document.obj.select.selectedIndex = i;        return;      }    }    document.obj.select.selectedIndex = -1;  }    this.changeCurObject = function(pos) {    this.selectObject(pos);  }    this.setObjectAttr = function(sAttrs) {    if(this.SelectedObjectId == undefined) return;    var obj = this.getObjById(this.SelectedObjectId);    type = this.getObjType(obj);    sAttrs = jQuery.trim(sAttrs);    //список атрибутов в текстовом поле    var aAttrs = new String(sAttrs).split("\n");    var tAttrs = new Array();    for(var i = 0; i < aAttrs.length; i++) {      var aAttr = aAttrs[i].split(":");      tAttrs[jQuery.trim(aAttr[0])] = jQuery.trim(aAttr[1]);    }        //перебираем все атрибуты    for(var i = 0; i < this.allowAttrs.length; i++) {      var curValue = obj.attr(this.allowAttrs[i]);      if(curValue != undefined) {        if((this.allowAttrs[i] == "scale" && type == "Line") == false) {//scale не применим для line          if(tAttrs[this.allowAttrs[i]] != curValue) {            //если значение изменилось            obj.attr(this.allowAttrs[i], tAttrs[this.allowAttrs[i]]);          }        }      }    }  }    //геттеры  this.getObjAttrs = function(obj) {    var arr = new Array();    var type = this.getObjType(obj);    function getObjAttr(name) {      if(obj.attr(name) != undefined) {        arr[arr.length] = new Array(name, obj.attr(name));      }    }    for(var i = 0; i < this.allowAttrs.length; i++) {      if((this.allowAttrs[i] == "scale" && type == "Line") == false) {        getObjAttr(this.allowAttrs[i]);      }    }    return arr;  }    this.getObjAttrString = function(obj) {    var atrArr = this.getObjAttrs(obj);    var AtrrString = "";    for(var i = 0; i < atrArr.length; i++) {      AtrrString += atrArr[i][0]+": "+atrArr[i][1]+"\n";    }    return AtrrString;  }  this.hasChanges = function() {    return this.elements.length > 0;  }    this.getContent = function() {    return $(this.position).html();  }    this.getCountImages = function() {    return $(this.position).children("image").length;  }    this.getObjById = function(id) {    if(id == undefined) return;    return this.elements[id];  }    this.isImage = function(obj) {    return (obj != undefined) && (obj.attr("src") != undefined);  }    this.getObjType = function(obj) {    if(this.isImage(obj)) return 'Image';    if(obj.attr("font") != undefined) return 'Text';    if(obj.attr("cx") != undefined) {//circle, ellipse      if(obj.attr("rx") != undefined) return 'Ellipse';      return 'Circle';    }    if(obj.attr("x") != undefined) return 'Rect';    if(obj.attr("path") != undefined) return 'Line';  }    //приоритеты объектов  this.BackgroundCurObj = function() {    //TODO на последовательный перенос    if(this.SelectedObjectId == undefined) return;    this.getObjById(this.SelectedObjectId).toBack();    return;    if(this.SelectedObjectId < 1||this.SelectedObjectId == undefined) return;    var bg = this.getObjById(this.SelectedObjectId-1);    var selObj = this.getObjById(this.SelectedObjectId);    selObj.insertBefore(bg);    var tmp = bg;    bg = selObj;    selObj = tmp;  }    this.ForegroundCurObj = function() {    if(this.SelectedObjectId == undefined) return;    this.getObjById(this.SelectedObjectId).toFront();    return;    if(this.SelectedObjectId >= this.elements.length-1||this.SelectedObjectId == undefined) return;    var fore = this.getObjById(this.SelectedObjectId+1);    var selObj = this.getObjById(this.SelectedObjectId);    selObj.insertAfter(fore);    var tmp = fore;    fore = selObj;    selObj = tmp;  }    this.DeleteCurObj = function() {     if(this.SelectedObjectId == undefined) return;     this.getObjById(this.SelectedObjectId).remove();     if(this.ImageStroke[this.SelectedObjectId] != undefined) {      this.ImageStroke[this.SelectedObjectId].remove();     }     delete this.elements[this.SelectedObjectId];     document.obj.select.options[this.SelectedObjectId] = null;     document.obj.select.selectedIndex = -1;     this.SelectedObjectId = undefined;     $("#attr").val('');  }    //объекты  this.insertNewImage = function(img, w, h) {    var del_x = 100*this.getCountImages();    var del_y = del_x;    if(del_x > this.width - w) {      del_x = this.width - w;    }    if(del_y > this.height - h) {      del_y = this.height - h;    }    this.createImage(img, del_x, del_y, w, h);  }    this.createImageStroke = function(ImagePos, x, y, w, h) {    //создаем вместе с изображением невидимое выделение    var delta = 1;    x = x-1;    if(x < 0)  {      x = 0;      delta = 0;    }    y = y-1;    if(y < 0)  {      y = 0;      delta = 0;    }    this.ImageStroke[ImagePos] = this.canvas.rect(x, y, delta + w, delta + h);    this.ImageStroke[ImagePos].hide();  }    this.createImage = function(img, x, y, w, h) {    var im = this.canvas.image(img, x, y, w, h);    var pos = this.elements.length;    this.elements[pos] = im;    this.createImageStroke(pos, x, y, w, h);    this.registrHoverEvent(pos);    this.registrDragEvents(pos);    this.registrOnListObj(pos);  }    this.registrOnListObj = function(pos) {    document.obj.select.options[document.obj.select.options.length] = new Option(this.getObjType(this.getObjById(pos)), pos);  }    this.registrMouseUpEvent = function(pos) {    var tmp = this;        this.registrOnListObj(pos);    this.registrHoverEvent(pos);    this.registrDragEvents(pos);        $(this.position).mouseup(function(e) {      //unbind      $(tmp.position).unbind('mousedown');      $(tmp.position).unbind('mouseup');      $(tmp.position).unbind('mousemove');    });  }    this.Circle = function() {    var tmp = this;    var circle = this.canvas.circle(0, 0, 1);    circle.attr({"fill": "#ffffff", "fill-opacity": 0}); //иначе подсветка не пашет    var pos = this.elements.length;    this.elements[pos] = circle;    circle.hide();        function getR(x1, y1, x2, y2) {      return Math.round(Math.abs(Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))));    }    this.registrMouseUpEvent(pos);    $(this.position).mousedown(function(e) {      var cord = tmp.mouseCoords(e, circle);      circle.attr({"cx": cord.x, "cy": cord.y, "r": 1});      circle.show();    });    $(this.position).mousemove(function(e) {      var cord = tmp.mouseCoords(e, circle);      circle.attr({"r": getR(circle.attr("cx"), circle.attr("cy"), cord.x, cord.y)});    });  }    this.Ellipse = function() {    var tmp = this;    var ellipse = this.canvas.ellipse(0, 0, 1, 1);    ellipse.attr({"fill": "#ffffff", "fill-opacity": 0}); //иначе подсветка не пашет    var pos = this.elements.length;    this.elements[pos] = ellipse;    ellipse.hide();    this.registrMouseUpEvent(pos);        $(this.position).mousedown(function(e) {      var cord = tmp.mouseCoords(e, ellipse);      ellipse.attr({"cx": cord.x, "cy": cord.y, "rx": 1, "ry": 1});      ellipse.show();    });    $(this.position).mousemove(function(e) {      var cord = tmp.mouseCoords(e, ellipse);      ellipse.attr({"rx": cord.x - ellipse.attr("cx"), "ry": cord.y - ellipse.attr("cy")});    });  }    this.Rect = function() {    var tmp = this;    var rect = this.canvas.rect(0, 0, 1, 1);    rect.attr({"fill": "#ffffff", "fill-opacity": 0}); //иначе подсветка не пашет    var pos = this.elements.length;    this.elements[pos] = rect;    rect.hide();    $(this.position).mousedown(function(e) {      var cord = tmp.mouseCoords(e);      rect.attr({"x": cord.x, "y": cord.y, "width": 1, "height": 1});      rect.show();    });    this.registrMouseUpEvent(pos);    $(this.position).mousemove(function(e) {      var cord = tmp.mouseCoords(e);      rect.attr({"width": cord.x-rect.attr("x"), "height": cord.y-rect.attr("y")});    });  }    this.Line = function() {    var tmp = this;    var line = this.canvas.path("M0 0L1 1");    var pos = this.elements.length;    this.elements[pos] = line;    line.hide();    var cords;    $(this.position).mousedown(function(e) {      cords = tmp.mouseCoords(e);      line.attr("path", "M"+cords.x+" "+cords.y+"L"+cords.x+" "+cords.y);      line.show();    });    this.registrMouseUpEvent(pos);    $(this.position).mousemove(function(e) {      var cordMove = tmp.mouseCoords(e);      if(cords != undefined) {        line.attr("path", "M"+cords.x+" "+cords.y+"L"+cordMove.x+" "+cordMove.y);      }    });  }    this.Text = function() {    var tmp = this;    var text = this.canvas.text(0, 0, this.version);    text.attr("font", '16px "Arial"');    var pos = this.elements.length;    this.elements[pos] = text;    this.registrMouseUpEvent(pos);    text.hide();        var cords;    $(this.position).mousedown(function(e) {      cords = tmp.mouseCoords(e);      text.attr({"x": cords.x, "y": cords.y});      text.show();    });  }    this.SetViewBox = function() {    if(this.browser.msie) {      //объекты почемуто смещаются      var k = this.width/this.height;      $(this.position).children("DIV:first-child").children(".rvml").attr("coordsize", (this.width - Math.round(this.viewMinus*2*k)) + "," + (this.height - this.viewMinus*2));      return;    }    this.canvas.canvas["setAttribute"]("viewBox", this.viewMinus + " " +                                                  this.viewMinus + " " +                                                  (this.width - this.viewMinus * 2) + " " +                                                  (this.height - this.viewMinus * 2));  }    this.ZoomIn = function() {    //this.canvas.canvas["setAttribute"]("transform", "scale(0.2)");    this.viewMinus = Math.round((this.height - this.viewMinus*2) / 5) + this.viewMinus;    this.SetViewBox();  }    this.ZoomOut = function() {    this.viewMinus = Math.round(this.viewMinus - this.viewMinus*2/5);    if(this.viewMinus < 3) {      this.viewMinus = 0; //вернемся к исходным    }    this.SetViewBox();  }}